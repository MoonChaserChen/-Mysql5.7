# 事务的隔离级别
## 事务的相互影响
### 脏读（Dirty Read）：
可能读取到其他会话中未提交事务修改的数据。脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，
这时，另外一个事务也访问这个数据，然后使用了这个数据。
### 不可重复读（NonRepeatable Read）：
在一个事务内，两次读取到的数据值不一致
是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，
由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，
因此称为是不可重复读。不可重复读的重点是修改。
### 幻读（Phantom Read）：
在一个事务内，两次读取到的数据量不一致
是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。 
同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，
以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。幻读的重点在于新增或者删除。

## 事务的隔离级别
为了减少事务之间的相互影响，达到隔离事务目的。一般来说隔离得越彻底，则数据库效率越低。Mysql有四种隔离级别：

| 隔离级别 | 脏读 | 不可重复读 | 幻读 |
| ---- | ---- | ---- | ---- |
| 未提交读 | 可能 | 可能 | 可能 |
| 已提交读 | 不可能 | 可能 | 可能 |
| 可重复读 | 不可能 | 不可能 | 可能 |
| 可串行化 | 不可能 | 不可能 | 不可能 |

## 实现方式
### 未提交读（Read Uncommitted）
啥都不做就会这样，一般情况下都不会使用这种隔离级别。

### 已提交读（Read Committed）
数据的读取都是不加锁的，但是数据的写入、修改和删除是需要加锁的。
在Mysql中的实现：

`update class_teacher set class_name='初三二班' where teacher_id=1;`

- teacher_id有索引

    给teacher_id的数据行加锁
- teacher_id无索引

    给class_teacher里所有数据加行锁。

### 可重复读（Repeatable Read）
**InnoDB默认的隔离级别**
1. 行锁

    该sql第一次读取到数据后，就将这些数据加锁，其它事务无法修改这些数据，就可以实现可重复读了。但不能解决幻读问题。
2. 表锁

    疯了吧，读个数据还锁表？
3. 读写锁（S锁，X锁）

    读用读锁，写用写锁，读锁和写锁互斥，这么做可以有效的避免幻读、不可重复读、脏读等问题，但会极大的降低数据库的并发能力（其实这样已经够好了）。
4. 正确姿势（乐观策略）

    [MVCC](/#MVCC)


### 可串行化（Serializable）
可串行化：读加共享锁，写加排他锁
这个级别很简单，读加共享锁，写加排他锁，读写互斥。使用的悲观锁的理论，实现简单，数据更加安全，但是并发能力非常差。
如果你的业务并发的特别少或者没有并发，同时又要求数据及时可靠的话，可以使用这种模式。
这里要吐槽一句，不要看到select就说不会加锁了，在Serializable这个级别，还是会加锁的！

## MVCC
MySQL、ORACLE、PostgreSQL等成熟的数据库，出于性能考虑，都是使用了以乐观策略为理论基础的MVCC（Multi-Version Concurrency Control多版本并发控制），
读不加锁，读写不冲突。

### MVCC的读
在MVCC并发控制中，读操作可以分为两类：快照读与当前读。
- 快照读

    简单的select操作，读取的是记录中的可见版本（可能是历史版本），不用加锁。

- 当前读

    特殊的select操作、insert、delete和update，读取的是记录中最新版本，并且当前读返回的记录都会加上锁，这样保证了了其他事务不会再并发修改这条记录。


