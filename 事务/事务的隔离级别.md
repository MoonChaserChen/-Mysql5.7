# 事务的隔离级别
## 事务的相互影响
### 脏读（Dirty Read）：
可能读取到其他会话中未提交事务修改的数据。脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，
这时，另外一个事务也访问这个数据，然后使用了这个数据。
### 不可重复读（NonRepeatable Read）：
在一个事务内，两次读取到的数据值不一致
是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，
由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，
因此称为是不可重复读。不可重复读的重点是修改。
### 幻读（Phantom Read）：
在一个事务内，两次读取到的数据量不一致
是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。 
同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，
以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。幻读的重点在于新增或者删除。

## 事务的隔离级别
为了减少事务之间的相互影响，达到隔离事务目的。一般来说隔离得越彻底，则数据库效率越低。Mysql有四种隔离级别：

| 隔离级别 | 脏读 | 不可重复读 | 幻读 |
| ---- | ---- | ---- | ---- |
| 未提交读 | 可能 | 可能 | 可能 |
| 已提交读 | 不可能 | 可能 | 可能 |
| 可重复读 | 不可能 | 不可能 | 可能 |
| 可串行化 | 不可能 | 不可能 | 不可能 |

## 实现方式
### 未提交读（Read Uncommitted）
啥都不做就会这样，一般情况下都不会使用这种隔离级别。

### 已提交读（Read Committed）
数据的读取都是不加锁的，但是数据的写入、修改和删除是需要加锁的。
在Mysql中的实现：

`update class_teacher set class_name='初三二班' where teacher_id=1;`

- teacher_id有索引

    给teacher_id的数据行加锁
- teacher_id无索引

    给class_teacher里所有数据加行锁。但在实际使用过程当中，MySQL做了一些改进，在MySQL Server过滤条件，发现不满足后，
    会调用unlock_row方法，把不满足条件的记录释放锁 (违背了二段锁协议的约束)。这样做，保证了最后只会持有满足条件记录上的锁，
    但是每条记录的加锁操作还是不能省略的。可见即使是MySQL，为了效率也是会违反规范的。（参见《高性能MySQL》中文第三版p181）

### 可重复读（Repeatable Read）
**InnoDB默认的隔离级别**
1. 行锁

    该sql第一次读取到数据后，就将这些数据加锁，其它事务无法修改这些数据，就可以实现可重复读了。但不能解决幻读问题。
2. 表锁

    疯了吧，读个数据还锁表？
3. 读写锁（S锁，X锁）

    读用读锁，写用写锁，读锁和写锁互斥，这么做可以有效的避免幻读、不可重复读、脏读等问题，但会极大的降低数据库的并发能力（其实这样已经够好了）。
4. 正确姿势（乐观策略）

    MySQL、ORACLE、PostgreSQL等成熟的数据库，出于性能考虑，都是使用了以乐观策略为理论基础的MVCC（多版本并发控制）。


### 可串行化（Serializable）
可串行化：读加共享锁，写加排他锁
这个级别很简单，读加共享锁，写加排他锁，读写互斥。使用的悲观锁的理论，实现简单，数据更加安全，但是并发能力非常差。
如果你的业务并发的特别少或者没有并发，同时又要求数据及时可靠的话，可以使用这种模式。
这里要吐槽一句，不要看到select就说不会加锁了，在Serializable这个级别，还是会加锁的！

